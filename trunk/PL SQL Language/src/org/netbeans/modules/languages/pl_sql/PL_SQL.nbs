TOKEN:block_comment: ("/*" - "*/")
#TOKEN:line_comment: ( "--"i | "--"i [^ "\n" "\r"]* ) 
TOKEN:line_comment: ( "--"i [^ "\n" "\r"]* )
TOKEN:whitespace:( [" " "\t" "\n" "\r"]+ )
TOKEN:operator: (
    ":=" | "+" | "-" | "*" | "/" | "**" | "||" | "PRIOR"i | "CONNECT_BY_ROOT"i |
    "UNION"i | "UNION ALL"i | "INTERSECT"i | "MINUS"i | "MULTISET EXCEPT"i |
    "MULTISET INTERSECT"i | "MULTISET UNION"i | "=" | "<>" | "!=" | "~=" |
    "^=" | ">" | "<" | "<=" | ">=" | "LIKE"i | "BETWEEN"i |
    ".." | "ANY"i | "SOME"i |
    "ALL"i | "EXISTS"i | "ESCAPE"i | "(+)" | "(" | ")"
)
TOKEN:or_operator: ( "OR"i )
TOKEN:and_operator: ( "AND"i )
TOKEN:not_operator: ( "NOT"i )

TOKEN:number_unsigned: (
    ["0"-"9"]*"."?["0"-"9"]+(["e" "E"]["+" "-"]?["0"-"9"]+)?
)
#TOKEN:number: (
    #["0"-"9"]+ |
    #["+" "-"]? ["0"-"9"]+
#    ["+" "-"]?["0"-"9"]*"."?["0"-"9"]+(["e" "E"]["+" "-"]?["0"-"9"]+)?
#)
TOKEN:string: ( "\'" ( 
        ([^ "\'"])*([ "\'"][ "\'"])*([^ "\'"])*
    )* "\'" )
TOKEN:some_types: (
    "NATURAL"i | "PLS_INTEGER"i | "NATURALN"i | "POSITIVE"i | "POSITIVEN"i |
    "SIGNTYPE"i | "SIMPLE_INTEGER"i | "INT"i | "INTEGER"i | "SMALLINT"i |
    "BINARY_INTEGER"i | "REAL"i | "BINARY_DOUBLE"i | "BINARY_FLOAT"i |
    "LONG"i | "LONG RAW"i | "ROWID"i | "UROWID"i | "BOOLEAN"i | "MLSLABEL"i |
    "DATE"i | "BFILE"i | "BLOB"i | "CLOB"i | "NCLOB"i
)
TOKEN:scale_types: ( ("NUMBER"i | "DEC"i | "DECIMAL"i | "NUMERIC"i)
( ("(" "+"? ["0"-"9"]+ ")") |
  ("(" "+"? ["0"-"9"]+ "," ["+" "-"]? ["0"-"9"]+ ")") )?
)
TOKEN:size_types: ( ("DOUBLE PRECISION"i | "FLOAT"i)
( "(" "+"? ["0"-"9"]+ ")" )?
)
TOKEN:char_types: ( 
    ("VARCHAR"i | "VARCHAR2"i | "NCHAR"i | "NVARCHAR2"i)
)
TOKEN:char_type: ( 
    ("CHAR"i)
)
TOKEN:byte_type: ( 
    ("BYTE"i)
)
TOKEN:raw_type: ( "RAW"i "(" "+"? ["0"-"9"]+ ")" )
TOKEN:timestamp_type: ( "TIMESTAMP"i
    ( "(" "+"? ["0"-"9"] ")" )?
)
TOKEN:year_type: ( "YEAR"i
    ( "(" "+"? ["0"-"4"] ")" )?
)
TOKEN:day_type: ( "DAY"i
    ( "(" "+"? ["0"-"9"] ")" )?
)
TOKEN:second_type: ( "SECOND"i
    ( "(" "+"? ["0"-"9"] ")" )?
)

TOKEN:keyword: (
    "SELECT"i | "." |
    "FROM"i | "WHERE"i
)
TOKEN:begin_keyword: ( "BEGIN"i )
TOKEN:end_keyword: ( "END"i )
TOKEN:declare_keyword: ( "DECLARE"i )
TOKEN:exception_keyword: ( "EXCEPTION"i )
TOKEN:when_keyword: ( "WHEN"i )
TOKEN:then_keyword: ( "THEN"i )
TOKEN:not_null_keyword: ( "NOT NULL"i )
TOKEN:null_keyword: ( "NULL"i )
TOKEN:default_keyword: ( "DEFAULT"i )
TOKEN:rowtype_keyword: ( "%ROWTYPE"i )
TOKEN:like_type_keyword: ( "%TYPE"i )
TOKEN:type_keyword: ( "TYPE"i )
TOKEN:true_keyword: ( "TRUE"i )
TOKEN:false_keyword: ( "FALSE"i )
TOKEN:constant_keyword: ( "CONSTANT"i )
TOKEN:with_keyword: ( "WITH"i )
TOKEN:local_keyword: ( "LOCAL"i )
TOKEN:time_keyword: ( "TIME"i)
TOKEN:zone_keyword: ( "ZONE"i)
TOKEN:interval_keyword: ( "INTERVAL"i)
TOKEN:to_keyword: ( "TO"i)
TOKEN:month_keyword: ( "MONTH"i)
TOKEN:subtype_keyword: ( "SUBTYPE"i )
TOKEN:is_keyword: ( "IS"i )
TOKEN:record_keyword: ( "RECORD"i )
TOKEN:create_keyword: ( "CREATE"i )
TOKEN:replace_keyword: ( "REPLACE"i )
TOKEN:function_keyword: ( "FUNCTION"i )
TOKEN:as_keyword: ( "AS"i )
TOKEN:return_keyword: ( "RETURN"i )
TOKEN:in_keyword: ( "IN"i )
TOKEN:out_keyword: ( "OUT"i )
TOKEN:nocopy_keyword: ( "NOCOPY"i )
TOKEN:authid_keyword: ( "AUTHID"i )
TOKEN:current_user_keyword: ( "CURRENT_USER"i )
TOKEN:definer_keyword: ( "DEFINER"i )
TOKEN:deterministic_keyword: ( "DETERMINISTIC"i )
TOKEN:parallel_enabled_keyword: ( "PARALLEL_ENABLED"i )
TOKEN:pipelined_keyword: ( "PIPELINED"i )
TOKEN:result_cache_keyword: ( "RESULT_CACHE"i )
TOKEN:procedure_keyword: ( "PROCEDURE"i )
TOKEN:if_keyword: ( "IF"i )
TOKEN:else_keyword: ( "ELSE"i )
TOKEN:elsif_keyword: ( "ELSIF"i )
TOKEN:endif_keyword: ( "END IF"i )
TOKEN:is_null_keyword: ( "IS NULL"i )
TOKEN:is_not_null_keyword: ( "IS NOT NULL"i )
TOKEN:not_in_keyword: ( "NOT IN"i )
 
TOKEN:identifier:( ["a"-"z" "A"-"Z"] ["$" "#" "_" "0"-"9" "a"-"z" "A"-"Z"]* )
TOKEN:ext_identifier:( 
    ["a"-"z" "A"-"Z"] ["$" "#" "_" "0"-"9" "a"-"z" "A"-"Z"]* ["." "@"]
    ["a"-"z" "A"-"Z"] ["$" "#" "_" "0"-"9" "a"-"z" "A"-"Z"]* (["." "@"]?
    ["a"-"z" "A"-"Z"] ["$" "#" "_" "0"-"9" "a"-"z" "A"-"Z"]*)?
)

TOKEN:separator: ( ";" )
TOKEN:terminator: ( "/" )
TOKEN:comma: ( "," )
TOKEN:param_value: ( "=>" )

SKIP:whitespace
SKIP:block_comment
SKIP:line_comment

#FOLD:block_comment: {
#    fold_display_name:"LBL_Comment";
#    expand_type_action_name:"Expand Comments";
#    collapse_type_action_name:"Collapse Comments"; 
#}
#FOLD:block_comment: {
#    fold_display_name:"LBL_HTML_Comment";
#    expand_type_action_name:"LBL_Expand_HTML_Comment";
#    collapse_type_action_name:"LBL_Collapse_HTML_Comment";
#} 

# Grammar 
S = (Source_Element)*;
Source_Element = Anonymous_Block | ([Create_Replace_Part] (Function_Declaration | Procedure_Declaration));
Universal_Identifier = <identifier> | <ext_identifier>;
#Statement = WhileStatement | IfStatement | ExpressionStatement | Block;
#WhileStatement = "while" "(" ConditionalExpression ")" Block;
#IfStatement = "if" "(" ConditionalExpression ")" "then" Block ["else" Block] ";";
#Block = <keyword, "begin"> (Statement)* <keyword, "end">;
Create_Replace_Part = <create_keyword> [<or_operator> <replace_keyword>];
As_Is_Part = <is_keyword> | <as_keyword>;
Parameter_Type = <in_keyword> | (<out_keyword> [<nocopy_keyword>]) | (<in_keyword> <out_keyword> [<nocopy_keyword>]);
Parameter_Declaration = "(" <identifier> [Parameter_Type] Data_Type [Variable_Def_Part Expression]
                        ("," <identifier> [Parameter_Type] Data_Type [Variable_Def_Part Expression])* ")";
Function_Spec = <function_keyword>
                Universal_Identifier [Parameter_Declaration] 
                <return_keyword> Data_Type [Invoker_Clause] (Function_Spec_Add2)*;
Invoker_Clause = <authid_keyword> (<current_user_keyword> | <definer_keyword>);
Function_Spec_Add2 = <deterministic_keyword> | <parallel_enabled_keyword> | <pipelined_keyword> | <result_cache_keyword>;
Function_Declaration = Function_Spec As_Is_Part 
                       (Variable_Declaration)* (Function_Declaration | Procedure_Declaration)* Block ;
Procedure_Spec = <procedure_keyword> Universal_Identifier [Parameter_Declaration] 
                 [Invoker_Clause];
Procedure_Declaration = Procedure_Spec As_Is_Part
                        (Variable_Declaration)* (Function_Declaration | Procedure_Declaration)* Block;
Block = <begin_keyword>
            (Executable_Section)+
            [Exception_Section]
        <end_keyword> [Universal_Identifier] [<separator>]
        ["/"];
Anonymous_Block = [Anonymous_Block_Declare_Section] Block;
Executable_Section = Statement | Inner_Anonymous_Block;
Inner_Anonymous_Block = Anonymous_Block_Declare_Section Block;
Statement = (Expression | Assigment_Statement |
            (<return_keyword> Expression ) | If_Statement ) <separator>;
If_Statement = <if_keyword> ["("] Expression [")"] <then_keyword> (Executable_Section)+
               [<elsif_keyword> ["("] Expression [")"] <then_keyword> (Executable_Section)+]
               [<else_keyword> (Executable_Section)+]
               <endif_keyword>;
Assigment_Statement = Universal_Identifier <operator, ":="> Expression;
Anonymous_Block_Declare_Section = <declare_keyword> (Variable_Declaration)+;

Variable_Declaration = <identifier> Data_Type 
                       [Variable_Declaration_Part] <separator>;
Variable_Declaration = <identifier> <constant_keyword> Data_Type 
                       Variable_Declaration_Part <separator>;
Variable_Declaration = Subtype_datatype <separator>;
Variable_Declaration = Record_datatype <separator>;
Variable_Declaration_Part = [<not_null_keyword>] Variable_Def_Part Expression;
Variable_Def_Part = <operator, ":="> | <default_keyword>;
Data_Type = <some_types> | <scale_types> | <size_types> | Char_Types | <raw_type> |
            Timestamp_Type | Interval_Year_Type | Interval_Day_Type | 
            Universal_Identifier | Special_datatype;
Char_Types = (<char_types> | <char_type>) ["(" ["+"] <number_unsigned> [<char_type> | <byte_type>] ")"];
Timestamp_Type = <timestamp_type> | 
    ( <timestamp_type> <with_keyword> [<local_keyword>] <time_keyword> <zone_keyword>);
Interval_Year_Type = <interval_keyword> <year_type> <to_keyword> <month_keyword>;
Interval_Day_Type = <interval_keyword> <day_type> <to_keyword> <second_type>;
Subtype_datatype = <subtype_keyword> <identifier> <is_keyword> Data_Type [<not_null_keyword>];

Record_datatype = <type_keyword> <identifier> <is_keyword> <record_keyword>
                  "(" Record_Field_Declaration ("," Record_Field_Declaration)* ")" ;
Record_Field_Declaration = <identifier> Data_Type [Variable_Declaration_Part];

Special_datatype = (<identifier> | <ext_identifier>) (<like_type_keyword> | <rowtype_keyword>);

#Expression = Boolean_expression | String_expression | Numeric_expression;
Expression = Universal_expression;
#Expression_In_Declare = String_expression | Boolean_Expression | Numeric_expression | Special_expression;# [Universal_Identifier];
Operator = "+" | "-" | "*" | "/" | "**" | "||" |
           "^=" | ">" | "<" | "<=" | ">=" | "=" | "<>" | "!=" | "~=" |
           <and_operator> | <or_operator> | <in_keyword> | <not_in_keyword>;
Unary_Op = <not_operator> | "+" | "-";
Postfix_Op = <is_null_keyword> | <is_not_null_keyword>;
Universal_expression = [Unary_Op] Universal_factor [Postfix_Op] (Operator Universal_expression)*;
Universal_factor = <true_keyword> | <false_keyword> | <number_unsigned> |
                   <string> | <null_keyword> |
                   Universal_Identifier [Call_Statement_Param] |
                   ("(" Universal_expression ("," Universal_expression )* ")");
Call_Statement_Param = ("(" Universal_expression ("," Universal_expression )* ")") |
                       ("(" <identifier> "=>" Universal_expression ("," <identifier> "=>" Universal_expression )* ")");

#Universal_expression = [Call_Statement ","] [Universal_operators] Universal_term (Universal_operators Universal_term )*;
#Universal_term = Universal_factor (Universal_operators Universal_factor)*;
#Universal_factor = (<true_keyword> | <false_keyword> | <number_unsigned> |
#                   <string> | <identifier> | <ext_identifier>) (<operator, ")">)*;
#Universal_operators = (<operator, "(">)* 
#                      (Operator | <not_operator> | <and_operator> | <or_operator>)
#                      (<operator, "(">)* 
#                      [<not_operator>];

String_expression = String_term (<operator, "||"> String_term)*;
String_term = <string> | <identifier> | <ext_identifier>;

Numeric_expression = [Numeric_operator1] Numeric_term (Numeric_operator1 Numeric_term)*;
Numeric_operator1 = (<operator, "(">)* (<operator, "+"> | <operator, "-">) (<operator, "(">)*;
Numeric_term = Numeric_factor (Numeric_operator2 Numeric_factor)*;
Numeric_operator2 = (<operator, "*"> | <operator, "/"> | <operator, "**">) (<operator, "(">)*;
Numeric_factor = (<number_unsigned> | <identifier> | <ext_identifier>) (<operator, ")">)*;

Boolean_expression = [(<operator, "(">)* <not_operator> (<operator, "(">)*] Boolean_term 
                     (<or_operator> (<operator, "(">)* [<not_operator> (<operator, "(">)*] Boolean_term)*;
Boolean_term = Boolean_factor (<and_operator> (<operator, "(">)* [<not_operator> (<operator, "(">)*] Boolean_factor)*;
Boolean_factor = (<true_keyword> | <false_keyword> | <identifier> | <ext_identifier>) (<operator, ")">)*;
		
Exception_Section = <exception_keyword> (Exception_Handler)+;
Exception_Handler = <when_keyword> <identifier> (<or_operator> <identifier>)*
                    <then_keyword> (Inner_Anonymous_Block | Block | Statement);
#Block = (Statement)*;
#gr_begin_stm = "BEGIN";
#ConditionalExpression = <identifier>;
#ExpressionStatement = <identifier>;

FOLD:Block: { fold_display_name:"begin...end"; }
FOLD:block_comment: { fold_display_name:"/*...*/"; }
FOLD:Function_Declaration: { fold_display_name:"function"; }
FOLD:Procedure_Declaration: { fold_display_name:"procedure"; }
FOLD:If_Statement: { fold_display_name:"if...end if"; }
#FOLD:Anonymous_Block: { fold_display_name:"begin...end"; }

BRACE "(:)"
BRACE "[:]"

COMPLETE "/*:*/"

#INDENT "<begin_keyword>:<end_keyword>" 
