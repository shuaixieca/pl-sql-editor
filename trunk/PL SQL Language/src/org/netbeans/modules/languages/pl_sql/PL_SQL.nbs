# PL/SQL Language definition based on Oracle 11g syntax
# Author: Alexandre Soumbatov
# Homepage: http://code.google.com/p/pl-sql-editor/

### Tokens ###
TOKEN:block_comment: ("/*" - "*/")
TOKEN:line_comment: ( "--"i [^ "\n" "\r"]* )
TOKEN:whitespace:( [" " "\t" "\n" "\r"]+ )
TOKEN:operator: (
    ":=" | "+" | "-" | "*" | "/" | "**" | "||" | "=" | "<>" | "!=" | "~=" |
    "^=" | ">" | "<" | "<=" | ">=" |
    ".." | "(+)" | "(" | ")" | "<<" | ">>"
)
TOKEN:or_operator: ( "OR"i )
TOKEN:and_operator: ( "AND"i )
TOKEN:not_operator: ( "NOT"i )

TOKEN:number_unsigned: (
    ["0"-"9"]*"."?["0"-"9"]+(["e" "E"]["+" "-"]?["0"-"9"]+)?
)
#TOKEN:number: (
    #["0"-"9"]+ |
    #["+" "-"]? ["0"-"9"]+
#    ["+" "-"]?["0"-"9"]*"."?["0"-"9"]+(["e" "E"]["+" "-"]?["0"-"9"]+)?
#)
TOKEN:string: ( "\'" ( 
        ([^ "\'"])*([ "\'"][ "\'"])*([^ "\'"])*
    )* "\'" )
TOKEN:some_types: (
    "NATURAL"i | "PLS_INTEGER"i | "NATURALN"i | "POSITIVE"i | "POSITIVEN"i |
    "SIGNTYPE"i | "SIMPLE_INTEGER"i | "INT"i | "INTEGER"i | "SMALLINT"i |
    "BINARY_INTEGER"i | "REAL"i | "BINARY_DOUBLE"i | "BINARY_FLOAT"i |
    "LONG"i | "LONG RAW"i | "ROWID"i | "UROWID"i | "BOOLEAN"i | "MLSLABEL"i |
    "DATE"i | "BFILE"i | "BLOB"i | "CLOB"i | "NCLOB"i
)
TOKEN:scale_types: ( ("NUMBER"i | "DEC"i | "DECIMAL"i | "NUMERIC"i)
( ("(" "+"? ["0"-"9"]+ ")") |
  ("(" "+"? ["0"-"9"]+ "," ["+" "-"]? ["0"-"9"]+ ")") )?
)
TOKEN:size_types: ( ("DOUBLE PRECISION"i | "FLOAT"i)
( "(" "+"? ["0"-"9"]+ ")" )?
)
TOKEN:char_types: ( 
    ("VARCHAR"i | "VARCHAR2"i | "NCHAR"i | "NVARCHAR2"i)
)
TOKEN:char_type: ( 
    ("CHAR"i)
)
TOKEN:byte_type: ( 
    ("BYTE"i)
)
TOKEN:raw_type: ( "RAW"i "(" "+"? ["0"-"9"]+ ")" )
TOKEN:timestamp_type: ( "TIMESTAMP"i
    ( "(" "+"? ["0"-"9"] ")" )?
)
TOKEN:year_type: ( "YEAR"i
    ( "(" "+"? ["0"-"4"] ")" )?
)
TOKEN:day_type: ( "DAY"i
    ( "(" "+"? ["0"-"9"] ")" )?
)
TOKEN:second_type: ( "SECOND"i
    ( "(" "+"? ["0"-"9"] ")" )?
)

### SQL keywords ###
TOKEN:keyword: (
    "." | "FROM"i | "WHERE"i | "GROUP BY"i | "ORDER BY"i | 
    "PRIOR"i | "CONNECT_BY_ROOT"i | "CONNECT"i | "START"i |
    "UNION"i | "UNION ALL"i | "INTERSECT"i | "MINUS"i | "MULTISET EXCEPT"i |
    "MULTISET INTERSECT"i | "MULTISET UNION"i |
    "ANY"i | "SOME"i | "ALL"i | "ESCAPE"i
)

### Because PL/SQL is case-insensitive language every PL/SQL keyword defined separately. ###
### Very inconvenient! ###
TOKEN:begin_keyword: ( "BEGIN"i )
TOKEN:end_keyword: ( "END"i )
TOKEN:declare_keyword: ( "DECLARE"i )
TOKEN:exception_keyword: ( "EXCEPTION"i )
TOKEN:when_keyword: ( "WHEN"i )
TOKEN:then_keyword: ( "THEN"i )
TOKEN:not_null_keyword: ( "NOT"i [" " "\t" "\n" "\r"]+ "NULL"i )
TOKEN:null_keyword: ( "NULL"i )
TOKEN:default_keyword: ( "DEFAULT"i )
TOKEN:rowtype_keyword: ( "%ROWTYPE"i )
TOKEN:like_type_keyword: ( "%TYPE"i )
TOKEN:type_keyword: ( "TYPE"i )
TOKEN:true_keyword: ( "TRUE"i )
TOKEN:false_keyword: ( "FALSE"i )
TOKEN:constant_keyword: ( "CONSTANT"i )
TOKEN:with_keyword: ( "WITH"i )
TOKEN:local_keyword: ( "LOCAL"i )
TOKEN:time_keyword: ( "TIME"i)
TOKEN:zone_keyword: ( "ZONE"i)
TOKEN:interval_keyword: ( "INTERVAL"i)
TOKEN:to_keyword: ( "TO"i)
TOKEN:month_keyword: ( "MONTH"i)
TOKEN:subtype_keyword: ( "SUBTYPE"i )
TOKEN:is_keyword: ( "IS"i )
TOKEN:record_keyword: ( "RECORD"i )
TOKEN:create_keyword: ( "CREATE"i )
TOKEN:replace_keyword: ( "REPLACE"i )
TOKEN:function_keyword: ( "FUNCTION"i )
TOKEN:as_keyword: ( "AS"i )
TOKEN:return_keyword: ( "RETURN"i )
TOKEN:in_keyword: ( "IN"i )
TOKEN:out_keyword: ( "OUT"i )
TOKEN:nocopy_keyword: ( "NOCOPY"i )
TOKEN:authid_keyword: ( "AUTHID"i )
TOKEN:current_user_keyword: ( "CURRENT_USER"i )
TOKEN:definer_keyword: ( "DEFINER"i )
TOKEN:deterministic_keyword: ( "DETERMINISTIC"i )
TOKEN:parallel_enabled_keyword: ( "PARALLEL_ENABLED"i )
TOKEN:pipelined_keyword: ( "PIPELINED"i )
TOKEN:result_cache_keyword: ( "RESULT_CACHE"i )
TOKEN:procedure_keyword: ( "PROCEDURE"i )
TOKEN:if_keyword: ( "IF"i )
TOKEN:else_keyword: ( "ELSE"i )
TOKEN:elsif_keyword: ( "ELSIF"i )
TOKEN:endif_keyword: ( "END"i [" " "\t" "\n" "\r"]+ "IF"i )
TOKEN:is_null_keyword: ( "IS"i [" " "\t" "\n" "\r"]+ "NULL"i )
TOKEN:is_not_null_keyword: ( "IS"i [" " "\t" "\n" "\r"]+ "NOT"i [" " "\t" "\n" "\r"]+ "NULL"i )
TOKEN:not_in_keyword: ( "NOT"i [" " "\t" "\n" "\r"]+ "IN"i )
TOKEN:goto_keyword: ( "GOTO"i )
TOKEN:loop_keyword: ( "LOOP"i )
TOKEN:end_loop_keyword: ( "END"i [" " "\t" "\n" "\r"]+ "LOOP"i )
TOKEN:while_keyword: ( "WHILE"i )
TOKEN:for_keyword: ( "FOR"i )
TOKEN:reverse_keyword: ( "REVERSE"i )
TOKEN:select_keyword: ( "SELECT"i )
TOKEN:count_keyword: ( "COUNT"i )
TOKEN:exception_init_keyword: ( "EXCEPTION_INIT"i )
TOKEN:like_keyword: ( "LIKE"i )
TOKEN:raise_keyword: ( "RAISE"i )
TOKEN:pragma_keyword: ( "PRAGMA"i )
TOKEN:autonomous_transaction_keyword: ( "AUTONOMOUS_TRANSACTION"i )
TOKEN:case_keyword: ( "CASE"i )
TOKEN:end_case_keyword: ( "END"i [" " "\t" "\n" "\r"]+ "CASE"i )
TOKEN:close_keyword: ( "CLOSE"i )
TOKEN:table_keyword: ( "TABLE"i )
TOKEN:of_keyword: ( "OF"i )
TOKEN:index_keyword: ( "INDEX"i )
TOKEN:by_keyword: ( "BY"i )
TOKEN:varray_keyword: ( "VARRAY"i )
TOKEN:varying_keyword: ( "VARYING"i )
TOKEN:array_keyword: ( "ARRAY"i )
TOKEN:commit_keyword: ( "COMMIT"i )
TOKEN:ref_keyword: ( "REF"i )
TOKEN:continue_keyword: ( "CONTINUE"i )
TOKEN:cursor_keyword: ( "CURSOR"i )
TOKEN:delete_keyword: ( "DELETE"i )
TOKEN:execute_keyword: ( "EXECUTE"i )
TOKEN:immediate_keyword: ( "IMMEDIATE"i )
TOKEN:exit_keyword: ( "EXIT"i )
TOKEN:into_keyword: ( "INTO"i )
TOKEN:using_keyword: ( "USING"i )
TOKEN:bulk_keyword: ( "BULK"i )
TOKEN:collect_keyword: ( "COLLECT"i )
TOKEN:fetch_keyword: ( "FETCH"i )
TOKEN:limit_keyword: ( "LIMIT"i )
TOKEN:forall_keyword: ( "FORALL"i )
TOKEN:save_keyword: ( "SAVE"i )
TOKEN:exceptions_keyword: ( "EXCEPTIONS"i )
TOKEN:indices_keyword: ( "INDICES"i )
TOKEN:values_keyword: ( "VALUES"i )
TOKEN:between_keyword: ( "BETWEEN"i )
TOKEN:inline_keyword: ( "INLINE"i )
TOKEN:insert_keyword: ( "INSERT"i )
TOKEN:lock_keyword: ( "LOCK"i )
TOKEN:merge_keyword: ( "MERGE"i )
TOKEN:open_keyword: ( "OPEN"i )
TOKEN:package_keyword: ( "PACKAGE"i )
TOKEN:body_keyword: ( "BODY"i )
TOKEN:restrict_references_keyword: ( "RESTRICT_REFERENCES"i )
TOKEN:returning_keyword: ( "RETURNING"i )
TOKEN:rollback_keyword: ( "ROLLBACK"i )
TOKEN:savepoint_keyword: ( "SAVEPOINT"i )
TOKEN:serially_reusable_keyword: ( "SERIALLY_REUSABLE"i )
TOKEN:set_keyword: ( "SET"i )
TOKEN:transaction_keyword: ( "TRANSACTION"i )
TOKEN:notfound_keyword: ( "%NOTFOUND"i )
TOKEN:found_keyword: ( "%FOUND"i )
TOKEN:isopen_keyword: ( "%ISOPEN"i )
TOKEN:rowcount_keyword: ( "%ROWCOUNT"i )
TOKEN:sqlcode_keyword: ( "SQLCODE"i )
TOKEN:sqlerrm_keyword: ( "SQLERRM"i )
TOKEN:update_keyword: ( "UPDATE"i )
TOKEN:exists_keyword: ( "EXISTS"i )
TOKEN:trigger_keyword: ( "TRIGGER"i )
TOKEN:before_keyword: ( "BEFORE"i )
TOKEN:after_keyword: ( "AFTER"i )
TOKEN:instead_keyword: ( "INSTEAD"i )
TOKEN:on_keyword: ( "ON"i )
TOKEN:nested_keyword: ( "NESTED"i )
TOKEN:referencing_keyword: ( "REFERENCING"i )
TOKEN:old_keyword: ( "OLD"i )
TOKEN:new_keyword: ( "NEW"i )
TOKEN:parent_keyword: ( "PARENT"i )
TOKEN:each_keyword: ( "EACH"i )
TOKEN:row_keyword: ( "ROW"i )
TOKEN:follows_keyword: ( "FOLLOWS"i )
TOKEN:enable_keyword: ( "ENABLE"i )
TOKEN:disable_keyword: ( "DISABLE"i )
TOKEN:oid_keyword: ( "OID"i )
TOKEN:object_keyword: ( "OBJECT"i )
TOKEN:under_keyword: ( "UNDER"i )
TOKEN:final_keyword: ( "FINAL"i )
TOKEN:instantiable_keyword: ( "INSTANTIABLE"i )
TOKEN:overriding_keyword: ( "OVERRIDING"i )
TOKEN:member_keyword: ( "MEMBER"i )
TOKEN:static_keyword: ( "STATIC"i )
TOKEN:constructor_keyword: ( "CONSTRUCTOR"i )
TOKEN:self_keyword: ( "SELF"i )
TOKEN:result_keyword: ( "RESULT"i )
TOKEN:map_keyword: ( "MAP"i )
TOKEN:order_keyword: ( "ORDER"i )
  
TOKEN:identifier:( ["a"-"z" "A"-"Z"] ["$" "#" "_" "0"-"9" "a"-"z" "A"-"Z" "%"]* )
TOKEN:ext_identifier:( 
    ":"? "\""? ["a"-"z" "A"-"Z"] ["$" "#" "_" "0"-"9" "a"-"z" "A"-"Z" "%"]* "\""? ["." "@"]
    "\""? ["a"-"z" "A"-"Z"] ["$" "#" "_" "0"-"9" "a"-"z" "A"-"Z"]* "\""? (["." "@"]?
    ["a"-"z" "A"-"Z"] ["$" "#" "_" "0"-"9" "a"-"z" "A"-"Z"]*)?
)
TOKEN:alias:( "\"" [^ "\""]+ "\""
)

TOKEN:separator: ( ";" )
TOKEN:terminator: ( "/" )
TOKEN:comma: ( "," )
TOKEN:param_value: ( "=>" )
TOKEN:quotation_mark: ( "\"" )

### the rest of ###
TOKEN:the_rest: ( . )

### Grammar ###
SKIP:whitespace
SKIP:block_comment
SKIP:line_comment
SKIP:wrapped
SKIP:the_rest

### S - grammar root element ###
#S = (Source_Element)*;
S = Source_Element;
Source_Element = Anonymous_Block | 
                 ([Create_Replace_Part]
                  (Function_Declaration | Procedure_Declaration | Package_Spec | Package_Body |
                   Trigger_Declaration | Type_Spec_Declaration | Type_Body_Declaration));
Identifier = <identifier> | <result_keyword> | <interval_keyword>;
Universal_Identifier = Identifier | <ext_identifier>;
Label = "<<" Identifier ">>";
#Statement = WhileStatement | IfStatement | ExpressionStatement | Block;
#WhileStatement = "while" "(" ConditionalExpression ")" Block;
#IfStatement = "if" "(" ConditionalExpression ")" "then" Block ["else" Block] ";";
#Block = <keyword, "begin"> (Statement)* <keyword, "end">;
Create_Replace_Part = <create_keyword> [<or_operator> <replace_keyword>];
As_Is_Part = <is_keyword> | <as_keyword>;
Parameter_Type = <in_keyword> | (<out_keyword> [<nocopy_keyword>]) | (<in_keyword> <out_keyword> [<nocopy_keyword>]);
Parameter_Declaration = "(" Identifier [Parameter_Type] Data_Type [Variable_Def_Part Expression]
                        ("," Identifier [Parameter_Type] Data_Type [Variable_Def_Part Expression])* ")";
Function_Spec = <function_keyword>
                Function_Name [Parameter_Declaration] 
                <return_keyword> Data_Type [Invoker_Clause] (Function_Spec_Add2)*;
Function_Name = Universal_Identifier | <alias>;
Invoker_Clause = <authid_keyword> (<current_user_keyword> | <definer_keyword>);
Function_Spec_Add2 = <deterministic_keyword> | <parallel_enabled_keyword> | <pipelined_keyword> | <result_cache_keyword>;
Function_Declaration = Function_Spec Function_Procedure_Body;
Procedure_Spec = <procedure_keyword> Procedure_Name [Parameter_Declaration] 
                 [Invoker_Clause];
Procedure_Name = Universal_Identifier | <alias>;
Procedure_Declaration = Procedure_Spec Function_Procedure_Body;
Function_Procedure_Body = As_Is_Part (Variable_Declaration)* (Function_Declaration | Procedure_Declaration)* Block;
Package_Spec = <package_keyword> Package_Spec_Name [Invoker_Clause] As_Is_Part
               (Variable_Declaration | ((Function_Spec | Procedure_Spec) ";"))* 
               <end_keyword> [Universal_Identifier] [<separator>] ["/"];
Package_Spec_Name = Universal_Identifier | <alias>;
Package_Body = <package_keyword> <body_keyword> Package_Body_Name As_Is_Part
               (Variable_Declaration | Function_Declaration | Procedure_Declaration)*
               [<begin_keyword> (Executable_Section)+]
               <end_keyword> [Universal_Identifier] [<separator>] ["/"];
Package_Body_Name = Universal_Identifier | <alias>;
Trigger_Declaration = <trigger_keyword> Trigger_Name Trigger_Type [Follows_Part] Trigger_Part
                      Anonymous_Block;
Trigger_Name = Universal_Identifier | <alias>;
Follows_Part = <follows_keyword> Universal_Identifier;
Trigger_Part = [<enable_keyword> | <disable_keyword>] [<when_keyword> Universal_expression];
Trigger_Type = (<before_keyword> (DML_Event_Clause | Non_DML_Trigger)) |
               (<after_keyword> (DML_Event_Clause | Non_DML_Trigger)) |
               (<instead_keyword> <of_keyword> DML_Event_Clause) |
               Compound_DML_Trigger;
Compound_DML_Trigger = <for_keyword> DML_Event_Clause [Referencing_Clause];
Non_DML_Trigger = (Identifier [<or_operator>])+ <on_keyword> Universal_Identifier;
DML_Event_Clause = ((<insert_keyword> | <delete_keyword> | 
                    (<update_keyword> [DML_Event_Clause_Factor]))
                    [<or_operator>] [DML_Event_Clause_Factor])+
                    DML_Event_Clause_Part [Referencing_Clause]
                    [<for_keyword> <each_keyword> <row_keyword>];
DML_Event_Clause_Factor = <of_keyword> (Universal_Identifier [<comma>])+;
DML_Event_Clause_Part = <on_keyword> ([<nested_keyword> <table_keyword> Identifier <of_keyword>] Universal_Identifier);
Referencing_Clause = <referencing_keyword> ( (<old_keyword> | <new_keyword> | <parent_keyword>)
                     [<as_keyword>] (<old_keyword> | <new_keyword> | Identifier) )+;
Type_Spec_Declaration = <type_keyword> Type_Spec_Name [Type_OID_Part] [Invoker_Clause] Type_Spec_Types
                        [<separator>] ["/"];
Type_Spec_Name = Universal_Identifier | <alias>;
Type_OID_Part = <oid_keyword> "'" Universal_Identifier "'" ;
Type_Spec_Types = Object_Type | Varray_Type | Nested_Table_Type;
Object_Type = ((As_Is_Part <object_keyword>) | (<under_keyword> Universal_Identifier))
              [Object_Type_Part]
               [[<not_operator>] <final_keyword>] [[<not_operator>] <instantiable_keyword>];
Object_Type_Part = "(" (Identifier Data_Type [","])+ (Element_Spec [","])* ")";
Element_Spec = [Inheritance_Clauses] ((Subprogram_Spec | Constructor_Spec | Map_Order_Function_Spec) [","])+
               [Pragma_Clause];
Pragma_Clause = <pragma_keyword> <restrict_references_keyword> "(" Expression ("," Expression)+ ")";
Map_Order_Function_Spec = (<map_keyword> | <order_keyword>) <member_keyword> Function_Spec;
Constructor_Spec = [<final_keyword>] [<instantiable_keyword>] <constructor_keyword> <function_keyword>
                   Data_Type [Constructor_Spec_Part];
Constructor_Spec_Part = "(" [<self_keyword> <in_keyword> <out_keyword> ","]
                        (Identifier Data_Type [","])+ ")"
                        <return_keyword> <self_keyword> <as_keyword> <result_keyword>;
Subprogram_Spec = (<member_keyword> | <static_keyword>) (Function_Spec | Procedure_Spec);
Inheritance_Clauses = [<not_operator>] (<final_keyword> | <instantiable_keyword> | <overriding_keyword>);
Varray_Type = As_Is_Part Collection_Varray_datatype;
Nested_Table_Type = As_Is_Part <table_keyword> <of_keyword> Data_Type;
Type_Body_Declaration = <type_keyword> <body_keyword> Type_Body_Name As_Is_Part
                        ((Subprogram_Declaration | Map_Order_Func_Declaration) [","] )+ <end_keyword>
                        [<separator>] ["/"];
Type_Body_Name = Universal_Identifier | <alias>;
Subprogram_Declaration = [<member_keyword> | <static_keyword>]
                         (Function_Declaration | Procedure_Declaration | Constructor_Declaration);
Constructor_Declaration = [<final_keyword>] [<instantiable_keyword>] <constructor_keyword> <function_keyword>
                          Data_Type [Constructor_Spec_Part] Function_Procedure_Body;
Map_Order_Func_Declaration = (<map_keyword> | <order_keyword>) <member_keyword> Function_Declaration;

Block = <begin_keyword>
            (Executable_Section)+
            [Exception_Section]
        <end_keyword> [Universal_Identifier] [<separator>]
        ["/"];
Anonymous_Block = [Anonymous_Block_Declare_Section] Block;
Executable_Section = Statement | Anonymous_Block;
Executable_Case_Section = ((Label)* Statements [<separator>]) | Anonymous_Block;
Statement = (Label)* Statements <separator>;
Statements = Expression | Goto_Statement | Loop_Statement |
             While_Loop_Statement | For_Loop_Statement | SQL_Statements |
             Return_Statement | If_Statement | Raise_Statement | Close_Statement |
             Continue_Statement | Execute_Immediate_Statement | Exit_Statement |
             Fetch_Statement | Forall_Statement | Pragma_Inline_Statement |
             Open_Statement;
SQL_Statements = Select_Statement | Commit_Statement | Delete_Statement | Update_Statement |
                 Insert_Statement | Lock_Table_Statement | Merge_Statement |
                 Rollback_Statement | Savepoint_Statement | Set_Transaction_Statement;
SQL_Operator = "+" | "-" | "*" | "/" | "**" | "||" | "=" | "<>" | "!=" | "~=" |
               "^=" | ">" | "<" | "<=" | ">=" | "(+)" | ",";
SQL_Not_Parsed = SQL_Not_Parsed1 | SQL_Not_Parsed2 | <the_rest>;
SQL_Not_Parsed1 = <alias> | <keyword> | SQL_Operator | <into_keyword> | <in_keyword> | <not_in_keyword> |
               <as_keyword> | <values_keyword> | <between_keyword> | <some_types> |
               <bulk_keyword> | <collect_keyword> | <returning_keyword> | <row_keyword> |
               <set_keyword> | <by_keyword> | <with_keyword> | <table_keyword>; 
SQL_Not_Parsed2 = <exists_keyword> | <replace_keyword> |
               <number_unsigned> | <count_keyword> | Universal_Identifier | Case_Statement_Expression |
               <string> | <comma> | <and_operator> | <or_operator> | <not_operator> |
               <is_not_null_keyword> | <is_null_keyword> | <null_keyword> | <like_keyword> | 
               SQL_Statements | SQL_Not_Parsed | ("(" (SQL_Not_Parsed)* ")");

### SQL Statements ###
Select_Statement = <select_keyword> (SQL_Not_Parsed | (<for_keyword> <update_keyword>))+;
Commit_Statement = <commit_keyword> [SQL_Not_Parsed];
Delete_Statement = <delete_keyword> (SQL_Not_Parsed)+;
Insert_Statement = <insert_keyword> (SQL_Not_Parsed)+;
Lock_Table_Statement = <lock_keyword> <table_keyword> (SQL_Not_Parsed)+;
Merge_Statement = <merge_keyword> (SQL_Not_Parsed | <on_keyword> |
                  <using_keyword> | <when_keyword> | <then_keyword> | <insert_keyword> |
                  <update_keyword>)+;
Rollback_Statement = <rollback_keyword> [SQL_Not_Parsed];
Savepoint_Statement = <savepoint_keyword> Identifier;
Set_Transaction_Statement = <set_keyword> <transaction_keyword> (SQL_Not_Parsed)+;
Update_Statement = <update_keyword> (SQL_Not_Parsed)+;

### PL/SQL Statements ###
Goto_Statement = <goto_keyword> Identifier;
Return_Statement = <return_keyword> [Expression];
If_Statement = <if_keyword> Expression <then_keyword> (Executable_Section)+
               (<elsif_keyword> Expression <then_keyword> (Executable_Section)+)*
               [<else_keyword> (Executable_Section)+]
               <endif_keyword>;
Loop_Statement = <loop_keyword> (Executable_Section)+ <end_loop_keyword> [Identifier];
While_Loop_Statement = <while_keyword> Expression Loop_Statement;
For_Loop_Statement = <for_keyword> Identifier <in_keyword> [<reverse_keyword>] 
                     ((Expression (For_Loop_Statement_Part | Cursor_For_Loop_Statement1)) |
                       Cursor_For_Loop_Statement2);
For_Loop_Statement_Part =  ".." Expression Loop_Statement;
Cursor_For_Loop_Statement1 = Loop_Statement;
Cursor_For_Loop_Statement2 = "(" Select_Statement ")" Loop_Statement;
Raise_Statement = <raise_keyword> [Universal_Identifier];
Case_Statement_Expression = Simple_Case_Statement_Expression | Searched_Case_Statement_Expression;
Simple_Case_Statement_Expression= <case_keyword> Expression 
                        (<when_keyword> Expression <then_keyword> (Executable_Case_Section)+)+
                        [<else_keyword> (Executable_Case_Section)+]
                        (<end_keyword> | (<end_case_keyword> [Identifier]));
Searched_Case_Statement_Expression = <case_keyword>
                        (<when_keyword> Expression <then_keyword> (Executable_Case_Section)+)+
                        [<else_keyword> (Executable_Case_Section)+]
                          (<end_keyword> | (<end_case_keyword> [Identifier]));
Close_Statement = <close_keyword> Universal_Identifier;
Continue_Statement = <continue_keyword> [Identifier] [<when_keyword> Expression];
Execute_Immediate_Statement = <execute_keyword> <immediate_keyword> Expression
                              [<return_keyword> | <returning_keyword>]
                              [Into_Clause | Bulk_Collect_Into_Clause]
                              [Using_Clause] ;
Into_Clause = <into_keyword> Universal_Identifier ("," Universal_Identifier)*;
Bulk_Collect_Into_Clause = <bulk_keyword> <collect_keyword> <into_keyword> 
                           Universal_Identifier ("," Universal_Identifier)*;
Using_Clause = <using_keyword> [<in_keyword> | <out_keyword> | (<in_keyword> <out_keyword>)] Expression
               ("," [<in_keyword> | <out_keyword> | (<in_keyword> <out_keyword>)] Expression)*;
Exit_Statement = <exit_keyword> [Identifier] [<when_keyword> Expression];
Fetch_Statement = <fetch_keyword> Expression 
                  ((Bulk_Collect_Into_Clause [<limit_keyword> Expression] ) | Into_Clause);
Forall_Statement = <forall_keyword> Identifier <in_keyword> Bounds_Clause
                   [<save_keyword> <exceptions_keyword>] SQL_Statements;
Bounds_Clause = (Expression ".." Expression) |
                (<indices_keyword> <of_keyword> Universal_Identifier 
                [<between_keyword> Expression <and_operator> Expression ]) |
                (<values_keyword> <of_keyword> Universal_Identifier) ;
Pragma_Inline_Statement = <pragma_keyword> <inline_keyword>
                          "(" <string> "," <string> ")";
Open_Statement = <open_keyword> Universal_Identifier [Open_Params]
                 [<for_keyword> (Select_Statement | <string> | Universal_Identifier) [Using_Clause]];
Open_Params = "(" Expression ("," Expression)* ")";
Sqlcode_Function = <sqlcode_keyword>;
Sqlerrm_Function = <sqlerrm_keyword> ["(" ["+"|"-"] <number_unsigned> ")"];
#Assigment_Statement = Universal_Identifier <operator, ":="> Expression;
Anonymous_Block_Declare_Section = <declare_keyword> 
                                  (Variable_Declaration)* 
                                  (Function_Declaration | Procedure_Declaration)*;
Variable_Declaration = Identifier Data_Type 
                       [Variable_Declaration_Part] <separator>;
Variable_Declaration = Identifier <constant_keyword> Data_Type 
                       Variable_Declaration_Part <separator>;
Variable_Declaration = Subtype_datatype <separator>;
Variable_Declaration = Record_Collection_datatype <separator>;
Variable_Declaration = Identifier <exception_keyword> <separator>;
Variable_Declaration = <pragma_keyword> (<autonomous_transaction_keyword> | <serially_reusable_keyword> |
    (<exception_init_keyword> "(" Expression "," Expression ")") |
    (<restrict_references_keyword> "(" Expression ("," Expression)+ ")" ) ) <separator>;
Variable_Declaration = Cursor_datatype <separator>;
Variable_Declaration_Part = [<not_null_keyword>] Variable_Def_Part Expression;
Variable_Def_Part = <operator, ":="> | <default_keyword>;
Data_Type = <some_types> | <scale_types> | <size_types> | Char_Types | <raw_type> |
            Timestamp_Type | Interval_Year_Type | Interval_Day_Type | 
            ([<ref_keyword>] Universal_Identifier)| Special_datatype;
Char_Types = (<char_types> | <char_type>) ["(" ["+"] <number_unsigned> [<char_type> | <byte_type>] ")"];
Timestamp_Type = <timestamp_type> | 
    ( <timestamp_type> <with_keyword> [<local_keyword>] <time_keyword> <zone_keyword>);
Interval_Year_Type = <interval_keyword> <year_type> <to_keyword> <month_keyword>;
Interval_Day_Type = <interval_keyword> <day_type> <to_keyword> <second_type>;
Subtype_datatype = <subtype_keyword> Identifier <is_keyword> Data_Type [<not_null_keyword>];

Record_Collection_datatype = <type_keyword> Identifier <is_keyword> 
                            (Record_datatype | Collection_Table_datatype | Collection_Varray_datatype |
                            Ref_Cursor_datatype);
Record_datatype = <record_keyword> "(" Record_Field_Declaration ("," Record_Field_Declaration)* ")" ;
Record_Field_Declaration = Identifier Data_Type [Variable_Declaration_Part];
Collection_Table_datatype = <table_keyword> <of_keyword> Data_Type [<not_null_keyword>]
                      [<index_keyword> <by_keyword> Data_Type];
Collection_Varray_datatype = (<varray_keyword> | (<varying_keyword> <array_keyword>))
                             "(" ["+"] <number_unsigned> ")" <of_keyword> Data_Type [<not_null_keyword>];
Ref_Cursor_datatype = <ref_keyword> <cursor_keyword> [<return_keyword> Data_Type];
Cursor_datatype = <cursor_keyword> Identifier [Cursor_Parameter_Declaration]
                  [<return_keyword> DataType] [<is_keyword> Select_Statement];
Cursor_Parameter_Declaration = "(" Cursor_Parameter ("," Cursor_Parameter)* ")" ;
Cursor_Parameter = Identifier [<in_keyword>] Data_Type [Variable_Def_Part Expression];

Special_datatype = (Identifier | <ext_identifier>) (<like_type_keyword> | <rowtype_keyword>);

### expression ###
#Expression = Boolean_expression | String_expression | Numeric_expression;
Expression = Universal_expression;
#Expression_In_Declare = String_expression | Boolean_Expression | Numeric_expression | Special_expression;# [Universal_Identifier];
In_NotIn_Expression = (<in_keyword> | <not_in_keyword>) 
                      ( Universal_expression | ( "(" Select_Statement ")"));
#                      (("(" (Select_Statement | (Universal_expression ("," Universal_expression)* ) ) ")")
#                      | Universal_expression);
Operator = "+" | "-" | "*" | "/" | "**" | "||" | ":=" | "." |
           "^=" | ">" | "<" | "<=" | ">=" | "=" | "<>" | "!=" | "~=" |
           <and_operator> | <or_operator> |
           <like_keyword> | ([<not_operator>] <between_keyword>);
Unary_Op = <not_operator> | "+" | "-";
Postfix_Op = <is_null_keyword> | <is_not_null_keyword> | "(+)" ;
Universal_expression = [Unary_Op] Universal_factor [Postfix_Op] (Operator (Universal_expression | ("(" Select_Statement ")") ))*;
Universal_factor = <true_keyword> | <false_keyword> | <number_unsigned> |
                   In_NotIn_Expression |
                   <string> | <null_keyword> | Case_Statement_Expression |
                   Sub_Identifier [Call_Statement_Param [In_NotIn_Expression]] |
                   ("(" Universal_expression ("," Universal_expression )* ")");
Sub_Identifier = Sub_Identifier_factor | <replace_keyword> | Sqlcode_Function | Sqlerrm_Function;
Sub_Identifier_factor = Universal_Identifier [<notfound_keyword> | <found_keyword> |
                        <isopen_keyword> | <rowcount_keyword> | In_NotIn_Expression];
Call_Statement_Param = ("(" [Universal_expression ("," Universal_expression )*] ")") |
                       ("(" Identifier "=>" Universal_expression ("," Identifier "=>" Universal_expression )* ")" );
Exception_Section = <exception_keyword> (Exception_Handler)+;
Exception_Handler = <when_keyword> Universal_Identifier (<or_operator> Universal_Identifier)*
                    <then_keyword> (Executable_Section)+;

#Universal_expression = [Call_Statement ","] [Universal_operators] Universal_term (Universal_operators Universal_term )*;
#Universal_term = Universal_factor (Universal_operators Universal_factor)*;
#Universal_factor = (<true_keyword> | <false_keyword> | <number_unsigned> |
#                   <string> | Identifier | <ext_identifier>) (<operator, ")">)*;
#Universal_operators = (<operator, "(">)* 
#                      (Operator | <not_operator> | <and_operator> | <or_operator>)
#                      (<operator, "(">)* 
#                      [<not_operator>];

#String_expression = String_term (<operator, "||"> String_term)*;
#String_term = <string> | Identifier | <ext_identifier>;

#Numeric_expression = [Numeric_operator1] Numeric_term (Numeric_operator1 Numeric_term)*;
#Numeric_operator1 = (<operator, "(">)* (<operator, "+"> | <operator, "-">) (<operator, "(">)*;
#Numeric_term = Numeric_factor (Numeric_operator2 Numeric_factor)*;
#Numeric_operator2 = (<operator, "*"> | <operator, "/"> | <operator, "**">) (<operator, "(">)*;
#Numeric_factor = (<number_unsigned> | Identifier | <ext_identifier>) (<operator, ")">)*;

#Boolean_expression = [(<operator, "(">)* <not_operator> (<operator, "(">)*] Boolean_term 
#                     (<or_operator> (<operator, "(">)* [<not_operator> (<operator, "(">)*] Boolean_term)*;
#Boolean_term = Boolean_factor (<and_operator> (<operator, "(">)* [<not_operator> (<operator, "(">)*] Boolean_factor)*;
#Boolean_factor = (<true_keyword> | <false_keyword> | Identifier | <ext_identifier>) (<operator, ")">)*;
		
### code folding ###
FOLD:Block: { fold_display_name:"begin...end"; }
FOLD:block_comment: { fold_display_name:"/*...*/"; }
FOLD:Function_Declaration: { fold_display_name:"function"; }
FOLD:Procedure_Declaration: { fold_display_name:"procedure"; }
FOLD:If_Statement: { fold_display_name:"if...end if"; }
FOLD:Loop_Statement: { fold_display_name:"loop...end loop"; }
FOLD:Case_Statement_Expression: { fold_display_name:"case...end case"; }

### brace matching ###
BRACE "(:)"
BRACE "[:]"

### code completion ###
COMPLETE "/*:*/"
COMPLETE "<<:>>"
COMPLETE "(:)"
COMPLETE "[:]"

### indentation ###
INDENT "(:)"
INDENT "[:]"
INDENT "begin:end"
INDENT "BEGIN:END"
INDENT "if:end if"
INDENT "then:else"
INDENT "IF:END IF"
INDENT "THEN:ELSE"
INDENT "loop:end loop"
INDENT "LOOP:END LOOP"
INDENT "case:end case"
INDENT "CASE:END CASE"
#INDENT "\\s*(((if|while)\\s*\\(then|else\\s*|else\\s+if\\s*\\(|for\\s*\\(.*\\))[^{;]*)" 

### navigator ###
NAVIGATOR:Function_Spec: {
    display_name: "<html><font color=808080>function</font> $Function_Name$</html>";
    icon: "org/netbeans/modules/languages/pl_sql/images/FunctionsObj.png";
}
NAVIGATOR:Procedure_Spec: {
    display_name: "<html><font color=808080>procedure</font> $Procedure_Name$</html>";
    icon: "org/netbeans/modules/languages/pl_sql/images/ProceduresObj.png";
}
NAVIGATOR:Package_Spec: {
    display_name: "<html><font color=808080>package</font> $Package_Spec_Name$</html>";
    icon: "org/netbeans/modules/languages/pl_sql/images/PackagesObj.png";
}
NAVIGATOR:Package_Body: {
    display_name: "<html><font color=808080>package body</font> $Package_Body_Name$</html>";
    icon: "org/netbeans/modules/languages/pl_sql/images/PackagesBodyObj.png";
}
NAVIGATOR:Trigger_Declaration: {
    display_name: "<html><font color=808080>trigger</font> $Trigger_Name$</html>";
    icon: "org/netbeans/modules/languages/pl_sql/images/TriggersObj.png";
}
NAVIGATOR:Type_Spec_Declaration: {
    display_name: "<html><font color=808080>type</font> $Type_Spec_Name$</html>";
    icon: "org/netbeans/modules/languages/pl_sql/images/TypesObj.png";
}
NAVIGATOR:Type_Body_Declaration: {
    display_name: "<html><font color=808080>type body</font> $Type_Body_Name$</html>";
    icon: "org/netbeans/modules/languages/pl_sql/images/TypesBodyObj.png";
}
#NAVIGATOR:Parameter_Declaration: {
#    display_name: "<html><font color=808080>parameters</font></html>";
#}
#NAVIGATOR:Variable_Declaration: {
#    display_name: "<html><font color=808080>variables</font></html>";
#}
